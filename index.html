<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>è–èª•å…‰åŠ (å¤§è€³ç‹—å¤¢å¹»ç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    /* èƒŒæ™¯æ”¹ç‚ºç²‰å«©è‰²ç³» */
    background: linear-gradient(to bottom, #c1e8ff, #f9d5e5);
    font-family: 'Comic Sans MS', 'å¹¼åœ“', 'Segoe UI', sans-serif; /* å­—é«”æ”¹å¯æ„›ä¸€é» */
    user-select: none;
    cursor: none; /* éš±è—æ»‘é¼  */
    touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿæ²å‹• */
  }

  /* UI å±¤ */
  #ui-layer {
    position: absolute; top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 20;
  }

  /* é€šç”¨å±…ä¸­å®¹å™¨ */
  .center-overlay {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    pointer-events: auto; /* å…è¨±é»æ“Š */
  }

  /* --- å¤§è€³ç‹—é¢¨æ ¼é¢æ¿ --- */
  #start-panel, #victory-panel {
    /* èƒŒæ™¯æ”¹ç‚ºç²‰è—/ç²‰ç´…æ¼¸å±¤ï¼ŒåŠ ä¸Šé›²æœµèˆ¬çš„ç™½è‰²ç™¼å…‰é‚Šæ¡† */
    background: linear-gradient(135deg, #e0f7fa, #f8bbd0);
    padding: 5vmin; 
    border-radius: 30px; /* æ›´åœ“æ½¤ */
    text-align: center; 
    color: #5a8bae; /* æ·±ç²‰è—è‰²æ–‡å­— */
    border: 5px solid #ffffff; 
    box-shadow: 0 0 30px rgba(255, 255, 255, 0.8), inset 0 0 20px rgba(255,255,255,0.5);
    width: 85%; max-width: 450px;
    transition: opacity 0.3s;
  }
  
  #victory-panel {
      display: none;
      background: linear-gradient(135deg, #fff9c4, #b3e5fc); /* å‹åˆ©é¢æ¿ç¨å¾®é‡‘é»ƒä¸€é» */
  }

  h1 { 
      margin: 0 0 10px 0; font-size: 7vmin; 
      text-shadow: 3px 3px 0px #ffffff, 5px 5px 0px rgba(0,0,0,0.1); 
      color: #ff8fab; /* å¯æ„›ç²‰ç´…æ¨™é¡Œ */
  }
  p { font-size: 3.5vmin; margin-bottom: 20px; line-height: 1.6; color: #607d8b; font-weight: bold;}
  
  .victory-text {
    font-size: 5vmin; font-weight: bold; margin-bottom: 30px;
    color: #4dd0e1;
    text-shadow: 2px 2px 0px #ffffff; line-height: 1.4;
  }

  /* --- å¤§è€³ç‹—é¢¨æ ¼æŒ‰éˆ• --- */
  button {
    padding: 15px 40px;
    font-size: 5vmin; 
    background: linear-gradient(to bottom, #81d4fa, #4fc3f7); /* ç²‰è—æ¼¸å±¤ */
    color: white; 
    border: 4px solid #ffffff; 
    border-radius: 50px;
    cursor: pointer; 
    font-weight: bold;
    box-shadow: 0 6px 0 #29b6f6, 0 0 15px rgba(255,255,255,0.6);
    white-space: nowrap;
    font-family: inherit;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
  }
  button:active { transform: translateY(3px); box-shadow: 0 3px 0 #29b6f6; }

  /* --- é€²åº¦æ¢å®¹å™¨ (é›²æœµé¢¨) --- */
  #progress-container {
    position: absolute; 
    top: 12vmin; /* ç¨å¾®é¿é–‹ä¸Šé¢çš„é›²æœµé‚Šæ¡† */
    left: 50%;
    transform: translateX(-50%);
    width: 60%; max-width: 400px;
    height: 35px;
    background: rgba(255, 255, 255, 0.7); /* åŠé€æ˜ç™½è‰² */
    border: 3px solid #b3e5fc; /* ç²‰è—é‚Šæ¡† */
    border-radius: 20px;
    overflow: hidden;
    display: none; 
    box-shadow: 0 4px 10px rgba(179, 229, 252, 0.4);
  }

  /* é€²åº¦æ¢å¡«å…… (é¦¬å¡é¾è‰²) */
  #progress-bar {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #ffecb3, #f48fb1); /* ç²‰é»ƒåˆ°ç²‰ç´… */
    transition: width 0.3s ease-out;
    border-radius: 20px;
  }

  /* é€²åº¦æ–‡å­— */
  #progress-text {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    text-align: center; line-height: 32px;
    color: #5a8bae; font-weight: bold; 
    text-shadow: 1px 1px 0px #ffffff; letter-spacing: 1px;
  }

  /* è½åŠ›æç¤º */
  #listen-hint {
    position: absolute; top: 25%; 
    width: 100%;
    text-align: center; font-size: 15vmin; 
    color: #ff8fab; /* ç²‰ç´…è‰²æç¤º */
    font-weight: 900; 
    text-shadow: 4px 4px 0px #ffffff, 6px 6px 0px rgba(0,0,0,0.1); 
    display: none; opacity: 0; transition: opacity 0.3s;
    pointer-events: none;
  }
  #listen-hint.show { display: block; opacity: 1; }

  /* --- é è…³è¨­å®š (å“ç‰Œè¯åç‰ˆ - é…åˆæ·ºè‰²èƒŒæ™¯èª¿æ•´) --- */
  #footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    padding: 2vmin;
    /* èƒŒæ™¯æ”¹ç‚ºåŠé€æ˜ç²‰è—è‰²ï¼Œè®“ç™½è‰²æ–‡å­—è·³å‡ºä¾† */
    background-color: rgba(135, 206, 250, 0.5); 
    z-index: 30; 
    
    color: white;
    font-size: 5vmin; 
    font-weight: 900; 
    letter-spacing: 1px;
    /* å¢åŠ æ·±è‰²æé‚Šå¢åŠ å°æ¯” */
    text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    font-family: "Arial Black", "Microsoft JhengHei", "å¹¼åœ“", sans-serif;
  }

  /* Ace English æ¨£å¼ (ç¶­æŒå“ç‰Œè‰²ï¼Œä½†å¢åŠ æ·±è‰²æé‚Šç¢ºä¿æ¸…æ™°) */
  .ace-style {
    color: #FFB300; 
    text-shadow: 
      2px 0 0 #fff, -2px 0 0 #fff, 0 2px 0 #fff, 0 -2px 0 #fff, 
      1px 1px 2px rgba(0,0,0,0.4);
    margin-right: 5px;
  }

  /* ç¿Šè¯æ•™è‚² æ¨£å¼ */
  .yihua-style {
    color: #2ecc71; 
    text-shadow: 
      2px 0 0 #fff, -2px 0 0 #fff, 0 2px 0 #fff, 0 -2px 0 #fff, 
      1px 1px 2px rgba(0,0,0,0.4);
    margin-left: 5px;
  }

  .x-style {
    color: white;
    font-weight: normal;
    font-size: 0.8em; 
  }

  .hidden { display: none !important; }

  @media (min-width: 800px) {
    h1 { font-size: 3.5rem; }
    p { font-size: 1.4rem; }
    button { font-size: 1.8rem; }
    #listen-hint { font-size: 5rem; }
    .victory-text { font-size: 2.5rem; }
    #progress-container { top: 90px; height: 40px; }
    #progress-text { line-height: 38px; }
    #footer { font-size: 2rem; padding: 20px; }
  }
</style>
</head>
<body>

  <div id="listen-hint">ğŸ”Š Listen!</div>

  <div id="ui-layer">
    
    <div id="progress-container">
      <div id="progress-bar"></div>
      <div id="progress-text">0 / 20</div>
    </div>

    <div id="start-panel" class="center-overlay">
      <h1>â˜ï¸ Cinnamoroll Christmas â˜ï¸</h1>
      <p>1. è½è‹±æ–‡å–®å­—<br>2. ç­”å° 20 é¡Œé€šé—œ<br>3. ç”¨è»Ÿç¶¿ç¶¿å…‰åŠåˆ‡é–‹å¡ç‰‡ï¼</p>
      <button onclick="startGame()">Start ğŸ„</button>
    </div>

    <div id="victory-panel" class="center-overlay">
      <h1>ğŸ‰ So Fluffy! ğŸ‰</h1>
      <div class="victory-text">Bravo!<br>Youâ€™re a Christmas Vocabulary Master.</div>
      <button onclick="location.reload()">Play Again ğŸ”„</button>
    </div>

  </div>

  <div id="footer">
    <span class="ace-style">Ace English</span>
    <span class="x-style">x</span>
    <span class="yihua-style">ç¿Šè¯æ•™è‚²</span>è£½ä½œ
  </div>

<script>
// --- è³‡æ–™åº« (ç¶­æŒä¸è®Š) ---
const gameData = [
    { word: "Santa", icon: "ğŸ…", color: "#d32f2f" }, // é¡è‰²ç¨å¾®èª¿æŸ”å’Œä¸€é»
    { word: "Tree", icon: "ğŸ„", color: "#388e3c" },
    { word: "Gift", icon: "ğŸ", color: "#fbc02d" },
    { word: "Snowman", icon: "â›„", color: "#0288d1" },
    { word: "Star", icon: "â­", color: "#fbc02d" },
    { word: "Bell", icon: "ğŸ””", color: "#f57c00" },
    { word: "Cookie", icon: "ğŸª", color: "#795548" },
    { word: "Candy", icon: "ğŸ¬", color: "#c2185b" },
    { word: "Sock", icon: "ğŸ§¦", color: "#d32f2f" },
    { word: "Angel", icon: "ğŸ‘¼", color: "#fbc02d" },
    { word: "Reindeer", icon: "ğŸ¦Œ", color: "#795548" },
    { word: "Sleigh", icon: "ğŸ›·", color: "#d32f2f" },
    { word: "Elf", icon: "ğŸ§", color: "#388e3c" },
    { word: "Snowflake", icon: "â„ï¸", color: "#4fc3f7" },
    { word: "Candle", icon: "ğŸ•¯ï¸", color: "#f57c00" },
    { word: "Turkey", icon: "ğŸ¦ƒ", color: "#e64a19" },
    { word: "Ribbon", icon: "ğŸ€", color: "#c2185b" },
    { word: "Gloves", icon: "ğŸ§¤", color: "#009688" },
    { word: "Scarf", icon: "ğŸ§£", color: "#d32f2f" },
    { word: "Toy", icon: "ğŸ§¸", color: "#8e24aa" }
];

const phrasesCorrect = ["So Cute!", "Fluffy!", "Excellent!", "Great Job!", "Lovely!", "Wow!"];
const phrasesWrong = ["Try Again!", "Don't Give Up!", "Keep Going!", "Oops!", "Almost!", "You Can Do It!"];

let isGameRunning = false;
let correctCount = 0;
const MAX_SCORE = 20; 

let cards = [];
let particles = [];
let saberTrail = [];
let clouds = []; // æ–°å¢é›²æœµé™£åˆ—
let synth = window.speechSynthesis;
let currentTargetWord = "";
const SPEECH_RATE = 0.85; 

let R = {
    cardSize: 0, emojiSize: 0, baseTextSize: 0, borderW: 0, feedbackSize: 0, scoreSize: 0, leftLaneX: 0, rightLaneX: 0
};

let feedback = { text: "", life: 0, y: 0, scale: 1 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  
  calculateResponsiveSizes(); 

  // åˆå§‹åŒ–èƒŒæ™¯é›²æœµ
  for(let i=0; i<15; i++) {
    clouds.push({
      x: random(width), y: random(height/2), // åªåœ¨å®ƒåŠéƒ¨
      size: random(50, 150), speed: random(0.2, 0.8)
    });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calculateResponsiveSizes();
}

function calculateResponsiveSizes() {
    let minDim = min(width, height);
    let isPortrait = width < height;

    if (isPortrait) {
        R.cardSize = constrain(width * 0.22, 70, 140); // å¡ç‰‡ç¨å¾®å¤§ä¸€é»é»æ›´å¯æ„›
    } else {
        R.cardSize = constrain(height * 0.2, 90, 160);
    }

    R.emojiSize = R.cardSize * 0.6;
    R.baseTextSize = R.cardSize * 0.22;
    
    R.borderW = minDim * 0.04; // é‚Šæ¡†åšä¸€é»
    R.feedbackSize = minDim * 0.15;
    R.scoreSize = minDim * 0.06;

    R.leftLaneX = width * 0.25;
    R.rightLaneX = width * 0.75;
}

function startGame() {
  document.getElementById('start-panel').classList.add('hidden');
  document.getElementById('progress-container').style.display = 'block'; 
  if(synth) synth.speak(new SpeechSynthesisUtterance("")); 
  isGameRunning = true;
  correctCount = 0;
  updateProgressUI();
  setTimeout(startRound, 800);
}

function updateProgressUI() {
    let pct = (correctCount / MAX_SCORE) * 100;
    document.getElementById('progress-bar').style.width = pct + "%";
    document.getElementById('progress-text').innerText = correctCount + " / " + MAX_SCORE;
}

function startRound() {
  if(!isGameRunning) return;
  let targetData = random(gameData);
  currentTargetWord = targetData.word;
  let distractorData;
  do { distractorData = random(gameData); } while(distractorData.word === targetData.word);
  let hint = document.getElementById('listen-hint');
  hint.classList.add('show');
  hint.innerText = "ğŸ”Š Listen...";
  speak(targetData.word, null, SPEECH_RATE);
  setTimeout(() => {
    hint.classList.remove('show');
    spawnCards(targetData, distractorData);
  }, 1000); 
}

function spawnCards(target, distractor) {
  let items = [target, distractor];
  if (random() > 0.5) items.reverse();
  launchCard(R.leftLaneX, height + 80, R.leftLaneX, height * 0.2, items[0], items[0].word === currentTargetWord);
  launchCard(R.rightLaneX, height + 80, R.rightLaneX, height * 0.2, items[1], items[1].word === currentTargetWord);
}

function launchCard(startX, startY, destX, destY, data, isTarget) {
    let gravity = 0.06; 
    let heightDiff = startY - destY;
    let vy = -Math.sqrt(2 * gravity * heightDiff); 
    let vx = (destX - startX) * 0.01; 

    cards.push({
        x: startX, y: startY, vx: vx, vy: vy, gravity: gravity,
        size: R.cardSize, angle: 0, rotSpeed: random(-0.005, 0.005), 
        data: data, isTarget: isTarget,
        draw: function() {
            push();
            translate(this.x, this.y); rotate(this.angle);
            
            // *** å¡ç‰‡ç¹ªè£½ï¼šæ”¹ç‚ºåœ“æ½¤é›²æœµå½¢ç‹€ ***
            fill(255, 255, 255, 240); // åŠé€æ˜ç™½è‰²
            stroke(isTarget ? "#ff8fab" : "#b3e5fc"); // ç²‰ç´…æˆ–ç²‰è—é‚Šæ¡†
            strokeWeight(4);
            // ä½¿ç”¨è¶…å¤§åœ“è§’çŸ©å½¢æ¨¡æ“¬é›²æœµ/å¡ç‰‡
            rect(0, 0, this.size, this.size * 1.3, this.size/2); 
            
            textSize(R.emojiSize); noStroke(); text(this.data.icon, 0, -this.size*0.15);
            
            let finalFontSize = R.baseTextSize;
            let wordLen = this.data.word.length;
            if (wordLen > 6) finalFontSize = R.baseTextSize * 0.85;
            if (wordLen > 8) finalFontSize = R.baseTextSize * 0.7;

            // æ–‡å­—é¡è‰²æ”¹ç‚ºæ·±ç²‰è—è‰²
            fill("#5a8bae"); textSize(finalFontSize); textStyle(BOLD); text(this.data.word, 0, this.size*0.4);
            pop();
        },
        update: function() {
            this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.angle += this.rotSpeed;
        }
    });
}

function draw() {
  // *** èƒŒæ™¯ç¹ªè£½ï¼šå¤¢å¹»æ¼¸å±¤ + é›²æœµ ***
  setGradient(0, 0, width, height, color("#c1e8ff"), color("#f9d5e5")); // ç²‰è—åˆ°ç²‰ç´…
  drawClouds();
  
  // *** é‚Šæ¡†ç¹ªè£½ï¼šæ”¹ç‚ºè»Ÿç¶¿ç¶¿é›²æœµé‚Šæ¡† ***
  drawFluffyBorder();

  drawParticles(); 

  if(!isGameRunning) return;

  let isSaberActive = false;
  if (touches.length > 0) {
      isSaberActive = true;
      updateSaber(touches[0].x, touches[0].y);
  } else {
      updateSaber(mouseX, mouseY);
      isSaberActive = true; 
  }
  
  if (touches.length === 0 && 'ontouchstart' in window) {
      isSaberActive = false;
      saberTrail = []; 
  }

  let saberSpeed = dist(mouseX, mouseY, pmouseX, pmouseY);
  let isSlashing = saberSpeed > 5; 

  // ç¹ªè£½å¤§è€³ç‹—å°¾å·´å…‰åŠ
  drawSaberCinnamoroll();

  for (let i = cards.length - 1; i >= 0; i--) {
    let c = cards[i];
    if (!c) continue; 
    c.update();
    c.draw();

    if (isSaberActive && isSlashing && dist(mouseX, mouseY, c.x, c.y) < c.size/2 + 20) {
        handleHit(c, i);
        break; 
    } 
    else if (c.y > height + 200) {
      cards.splice(i, 1);
      if(cards.length === 0) setTimeout(startRound, 1000);
    }
  }

  drawFeedback();
}

function triggerVictory() {
    isGameRunning = false;
    cards = []; 
    document.getElementById('progress-container').style.display = 'none';
    const panel = document.getElementById('victory-panel');
    panel.style.display = 'flex';
    speak("Bravo! Youâ€™re a Christmas Vocabulary Master.", null, 0.9);
    setInterval(() => {
        // çˆ†ç‚¸ç‰¹æ•ˆæ”¹ç‚ºç²‰å«©è‰²ç³»
        createExplosion(random(width), random(height), random(['#ff8fab', '#b3e5fc', '#fff9c4']));
    }, 300);
}

function handleHit(card, index) {
  cards.splice(index, 1);
  createExplosion(card.x, card.y, card.data.color);
  if (card.isTarget) {
    correctCount++; 
    updateProgressUI(); 
    if (correctCount >= MAX_SCORE) { triggerVictory(); return; }
    triggerFeedback(true);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  } else {
    triggerFeedback(false);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  }
}

// --- ç‰¹æ•ˆèˆ‡å·¥å…·å‡½å¼ (ä¿®æ”¹ç‚ºç²‰å«©ç‰ˆ) ---

function createExplosion(x, y, colorHex) {
  // å°‡åŸå§‹é¡è‰²æ··åˆç™½è‰²ï¼Œä½¿å…¶è®Šç²‰å«©
  let baseColor = color(colorHex);
  let pastelColor = lerpColor(baseColor, color(255), 0.5);
  
  for (let i = 0; i < 30; i++) {
    particles.push(new Particle(x, y, pastelColor, 'debris'));
  }
  for (let i = 0; i < 25; i++) {
    // æ˜Ÿæ˜Ÿç«èŠ±æ”¹ç‚ºç²‰é»ƒ/ç™½è‰²
    particles.push(new Particle(x, y, random(['#fff9c4', '#ffffff']), 'sparkle'));
  }
}

class Particle {
    constructor(x, y, col, type) {
        this.x = x; this.y = y; this.col = col; this.type = type;
        let angle = random(TWO_PI);
        let speed = random(min(width,height)*0.01, min(width,height)*0.035); 
        this.vx = cos(angle) * speed; this.vy = sin(angle) * speed;
        this.life = 255; this.gravity = 0.3; this.friction = 0.95;
        let baseScale = min(width, height) / 800;
        // ç²’å­å½¢ç‹€ï¼šç¢å±‘æ”¹ç‚ºåœ“å½¢ï¼Œæ˜Ÿæ˜Ÿç¶­æŒ
        this.size = (type === 'debris' ? random(6, 14) : random(4, 10)) * baseScale;
        this.rot = random(TWO_PI); this.rotSpeed = random(-0.2, 0.2);
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += this.gravity;
        this.vx *= this.friction; this.vy *= this.friction;
        this.life -= this.type === 'debris' ? 6 : 10;
        this.rot += this.rotSpeed; this.size *= 0.97;
    }
    draw() {
        push(); translate(this.x, this.y); rotate(this.rot); noStroke();
        let c = color(this.col); c.setAlpha(this.life); fill(c);
        if (this.type === 'debris') {
             circle(0,0, this.size); // åœ“å½¢ç¢å±‘
        } else { 
             blendMode(ADD); 
             // ç¹ªè£½æ˜Ÿæ˜Ÿå½¢ç‹€
             beginShape();
             for (let i = 0; i < 5; i++) {
                let angle = TWO_PI / 5 * i;
                let x = cos(angle) * this.size; let y = sin(angle) * this.size;
                vertex(x, y);
                angle += TWO_PI / 10;
                x = cos(angle) * this.size/2; y = sin(angle) * this.size/2;
                vertex(x, y);
             }
             endShape(CLOSE);
             blendMode(BLEND); 
        }
        pop();
    }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i]; p.update(); p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function triggerFeedback(isCorrect) {
    feedback.text = isCorrect ? random(phrasesCorrect) : random(phrasesWrong);
    feedback.life = 255; feedback.y = height / 2; feedback.scale = 0.5;
}

function drawFeedback() {
    if (feedback.life > 0) {
        push(); translate(width / 2, feedback.y); scale(feedback.scale);
        // é¼“å‹µèªæ”¹ç‚ºç²‰è—è‰²é…ç™½é‚Š
        drawingContext.shadowBlur = 20; drawingContext.shadowColor = '#b3e5fc';
        fill("#ffffff"); stroke("#4dd0e1"); strokeWeight(4);
        textSize(R.feedbackSize); textStyle(BOLD); text(feedback.text, 0, 0);
        feedback.life -= 4; feedback.y -= 1.5;
        if(feedback.scale < 1.2) feedback.scale += 0.05;
        drawingContext.shadowBlur = 0;
        pop();
    }
}

// *** æ–°å¢ï¼šç¹ªè£½èƒŒæ™¯é›²æœµ ***
function drawClouds() {
  noStroke(); fill(255, 255, 255, 150); // åŠé€æ˜ç™½é›²
  for(let c of clouds) {
    // ç°¡å–®ç”¨å¹¾å€‹åœ“å½¢çµ„åˆæˆé›²æœµ
    circle(c.x, c.y, c.size);
    circle(c.x + c.size*0.5, c.y + c.size*0.2, c.size*0.8);
    circle(c.x - c.size*0.5, c.y + c.size*0.2, c.size*0.8);
    c.x += c.speed;
    if(c.x > width + c.size) c.x = -c.size;
  }
}

// *** æ–°å¢ï¼šç¹ªè£½è»Ÿç¶¿ç¶¿é‚Šæ¡† ***
function drawFluffyBorder() {
  push(); noStroke(); fill(255, 255, 255, 200);
  let borderW = R.borderW * 1.2;
  // ä¸Šä¸‹
  for(let x=0; x<=width; x+=borderW*0.8) {
      circle(x, borderW/2, borderW);
      circle(x, height - borderW/2, borderW);
  }
  // å·¦å³
  for(let y=0; y<=height; y+=borderW*0.8) {
      circle(borderW/2, y, borderW);
      circle(width - borderW/2, y, borderW);
  }
  pop();
}

function updateSaber(x, y) {
  saberTrail.push({x: x, y: y, life: 10}); // è»Œè·¡ç¨å¾®é•·ä¸€é»
  for (let i = saberTrail.length - 1; i >= 0; i--) {
    saberTrail[i].life--;
    if (saberTrail[i].life <= 0) saberTrail.splice(i, 1);
  }
}

// *** ä¿®æ”¹ï¼šå¤§è€³ç‹—å°¾å·´é¢¨æ ¼å…‰åŠ ***
function drawSaberCinnamoroll() {
  if (saberTrail.length < 2) return;
  blendMode(ADD); 
  noFill(); strokeCap(ROUND); strokeJoin(ROUND);
  
  // æœ€å¤–å±¤ï¼šç²‰è—è‰²æŸ”å…‰
  stroke(179, 229, 252, 100); strokeWeight(R.borderW * 1.5);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();

  // ä¸­é–“å±¤ï¼šç™½è‰²æ¯›èŒ¸èŒ¸æ„Ÿ
  stroke(255, 255, 255, 180); strokeWeight(R.borderW * 0.8);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();

  // æ ¸å¿ƒï¼šäº®ç™½è‰²
  stroke(255, 255, 255, 255); strokeWeight(R.borderW * 0.3);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  
  blendMode(BLEND); 
}

function setGradient(x, y, w, h, c1, c2) {
  noFill();
  for (let i = y; i <= y + h; i+=5) {  // ç¨å¾®åŠ å¯†ä¸€é»è®“æ¼¸å±¤æ›´æŸ”å’Œ
    let inter = map(i, y, y + h, 0, 1);
    let c = lerpColor(c1, c2, inter);
    stroke(c); strokeWeight(6);
    line(x, i, x + w, i);
  }
}

function speak(text, callback, rate = 1.0) {
  synth.cancel();
  let u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US'; u.rate = rate; 
  if(callback) u.onend = callback;
  synth.speak(u);
}
</script>
</body>
</html>
